//------------------------------------------------------------------------------
// Types:
//------------------------------------------------------------------------------
type HagaCoreCommandArgs = string[];

type HagaCoreRule = {
    name: string;                     // unique identifier
    commands: HagaCoreCommandArgs[];  // multiple commands per rule
    description?: string | undefined; // optional human-readable description
    generator?: boolean;
};

type HagaCoreTarget = {
    type?: never;
    inputs: string[];
    outputs: string[];
    implicits?: string[] | undefined;
    orderOnly?: string[] | undefined;
    rule: string; // must match a HagaCoreRule.name
    restat?: boolean;
};

type HagaCoreExport = {
    rules: HagaCoreRule[];
    targets: HagaCoreTarget[];
};

type HagaOutputStream = (s: string) => void;

//------------------------------------------------------------------------------
// Implementation:
//------------------------------------------------------------------------------
/**
 * Converts a HagaCoreExport into a Ninja build file
 */
function writeNinjaBuild(coreExport: HagaCoreExport, outputStream: HagaOutputStream): void {
    outputStream(`# Autogenerated by Haga\n`);
    outputStream(`ninja_required_version = 1.10\n\n`);

    // Emit rules
    coreExport.rules.forEach(rule => {
        outputStream(`rule ${rule.name}\n`);

        // Join multiple commands into a single line with &&
        const commandLine = rule.commands
            .map((cmd) => cmd.map((arg) => escapeArg(arg)).join(" "))
            .join(" && ");
        outputStream(`  command = ${commandLine}\n`);

        // Optional description
        if (rule.description) {
            outputStream(`  description = ${rule.description}\n`);
        }

        if (rule.generator !== undefined) {
            outputStream(`  generator = ${rule.generator ? 1 : 0}\n`);
        }

        outputStream(`\n`);
    });

    // Emit build edges
    coreExport.targets.forEach(target => {
        const inputs = target.inputs.join(" ");
        const outputs = target.outputs.join(" ");
        outputStream(`build ${outputs}: ${target.rule} ${inputs}`);

        if (target.implicits != undefined) {
            const implicits = target.implicits.join(" ");
            outputStream(` | ${implicits}`);
        }

        if (target.orderOnly != undefined) {
            const orderOnly = target.orderOnly.join(" ");
            outputStream(` || ${orderOnly}`);
        }

        outputStream(`\n`);

        if (target.restat !== undefined) {
            outputStream(`  restat = ${target.restat ? 1 : 0}\n`);
        }

        outputStream(`\n`);
    });
}

/**
 * Escape arguments for Ninja command lines
 */
function escapeArg(arg: string): string {
    if (/[\s$"]/g.test(arg)) {
        // wrap in quotes and escape $
        return `"${arg.replace(/\$/g, "$$")}"`;
    }
    return arg;
}

//------------------------------------------------------------------------------
// Exports:
//------------------------------------------------------------------------------
export type {
    HagaCoreCommandArgs,
    HagaCoreRule,
    HagaCoreTarget,
    HagaCoreExport,
    HagaOutputStream,
};

export const HagaCore = {
    writeNinjaBuild,
};
