//------------------------------------------------------------------------------
// Types:
//------------------------------------------------------------------------------
type HagaCoreCommandArgs = string[];
type HagaCoreVars = Record<string, string>;

type HagaCoreRule = {
    name: string;                     // unique identifier
    commands: HagaCoreCommandArgs[];  // multiple commands per rule
    description?: string | undefined; // optional human-readable description
    generator?: boolean;
    restat?: boolean;
};

type HagaCoreTarget = {
    type?: never;
    inputs: string[];
    outputs: string[];
    implicits?: string[] | undefined;
    orderOnly?: string[] | undefined;
    regenImplicits?: string[] | undefined;
    rule: string; // must match a HagaCoreRule.name
    vars?: HagaCoreVars | undefined;
    all?: boolean; // include in "all" phony target? (default: true)
};

type HagaCoreExport = {
    rules: HagaCoreRule[];
    targets: HagaCoreTarget[];
};

type HagaOutputStream = (s: string) => void;

//------------------------------------------------------------------------------
// Implementation:
//------------------------------------------------------------------------------
/**
 * Converts a HagaCoreExport into a Ninja build file
 */
function writeNinjaBuild(coreExport: HagaCoreExport, outputStream: HagaOutputStream): void {
    outputStream(`# Autogenerated by Haga\n`);
    outputStream(`ninja_required_version = 1.10\n\n`);

    // Emit rules
    coreExport.rules.forEach(rule => {
        outputStream(`rule ${rule.name}\n`);

        // Join multiple commands into a single line with &&
        const commandLine = rule.commands
            .map((cmd) => cmd.map((arg) => escapeArg(arg)).join(" "))
            .join(" && ");
        outputStream(`  command = ${commandLine}\n`);

        // Optional description
        if (rule.description) {
            outputStream(`  description = ${rule.description}\n`);
        }
        if (rule.generator !== undefined) {
            outputStream(`  generator = ${rule.generator ? 1 : 0}\n`);
        }
        if (rule.restat !== undefined) {
            outputStream(`  restat = ${rule.restat ? 1 : 0}\n`);
        }

        outputStream(`\n`);
    });

    // Emit build edges
    coreExport.targets.forEach(target => {
        const inputs = target.inputs.join(" ");
        const outputs = target.outputs.join(" ");
        outputStream(`build ${outputs}: ${target.rule} ${inputs}`);

        if (target.implicits != undefined && target.implicits.length > 0) {
            const implicits = target.implicits.join(" ");
            outputStream(` | ${implicits}`);
        }

        if (target.orderOnly != undefined && target.orderOnly.length > 0) {
            const orderOnly = target.orderOnly.join(" ");
            outputStream(` || ${orderOnly}`);
        }

        outputStream(`\n`);

        if (target.vars) {
            for (const [key, val] of Object.entries(target.vars)) {
                outputStream(`  ${key} = ${val}\n`);
            }
        }

        outputStream(`\n`);
    });

    outputStream(`build all: phony`)
    for (const tgt of coreExport.targets) {
        if (tgt.all ?? true) {
            for (const outfile of tgt.outputs) {
                outputStream(` ${outfile}`);
            }
        }
    }
    outputStream(`\n\ndefault all\n`);
}

/**
 * Escape arguments for Ninja command lines
 */
function escapeArg(arg: string): string {
    // Escape $ for Ninja, but DO NOT quote
    return arg.replace(/\$/g, "$$");
}

//------------------------------------------------------------------------------
// Exports:
//------------------------------------------------------------------------------
export type {
    HagaCoreCommandArgs,
    HagaCoreRule,
    HagaCoreTarget,
    HagaCoreExport,
    HagaCoreVars,
    HagaOutputStream,
};

export const HagaCore = {
    writeNinjaBuild,
};
